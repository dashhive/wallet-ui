/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@noble/hashes@1.3.3/sha3.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 *
 * https://github.com/paulmillr/noble-hashes#sha3-fips-shake-keccak
 * https://esm.run/@noble/hashes/sha3.js
 * https://esm.run/@noble/hashes@1.3.3/esm/sha3.js
 * https://cdn.jsdelivr.net/npm/@noble/hashes/sha3.js/+esm
 */
function t(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function e(t,...e){if(!((n=t)instanceof Uint8Array||null!=n&&"object"==typeof n&&"Uint8Array"===n.constructor.name))throw new Error("Expected Uint8Array");var n;if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function n(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}const r=BigInt(2**32-1),s=BigInt(32);function o(t,e=!1){return e?{h:Number(t&r),l:Number(t>>s&r)}:{h:0|Number(t>>s&r),l:0|Number(t&r)}}function i(t,e=!1){let n=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let s=0;s<t.length;s++){const{h:i,l:h}=o(t[s],e);[n[s],r[s]]=[i,h]}return[n,r]}if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");function h(t){if("string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),!((e=t)instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name))throw new Error("expected Uint8Array, got "+typeof t);var e;return t}class u{clone(){return this._cloneInto()}}const[f,c,a]=[[],[],[]],l=BigInt(0),p=BigInt(1),d=BigInt(2),w=BigInt(7),y=BigInt(256),g=BigInt(113);for(let t=0,e=p,n=1,r=0;t<24;t++){[n,r]=[r,(2*n+3*r)%5],f.push(2*(5*r+n)),c.push((t+1)*(t+2)/2%64);let s=l;for(let t=0;t<7;t++)e=(e<<p^(e>>w)*g)%y,e&d&&(s^=p<<(p<<BigInt(t))-p);a.push(s)}const[b,k]=i(a,!0),L=(t,e,n)=>n>32?((t,e,n)=>e<<n-32|t>>>64-n)(t,e,n):((t,e,n)=>t<<n|e>>>32-n)(t,e,n),I=(t,e,n)=>n>32?((t,e,n)=>t<<n-32|e>>>64-n)(t,e,n):((t,e,n)=>e<<n|t>>>32-n)(t,e,n);function A(t,e=24){const n=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let e=0;e<10;e++)n[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const r=(e+8)%10,s=(e+2)%10,o=n[s],i=n[s+1],h=L(o,i,1)^n[r],u=I(o,i,1)^n[r+1];for(let n=0;n<50;n+=10)t[e+n]^=h,t[e+n+1]^=u}let e=t[2],s=t[3];for(let n=0;n<24;n++){const r=c[n],o=L(e,s,r),i=I(e,s,r),h=f[n];e=t[h],s=t[h+1],t[h]=o,t[h+1]=i}for(let e=0;e<50;e+=10){for(let r=0;r<10;r++)n[r]=t[e+r];for(let r=0;r<10;r++)t[e+r]^=~n[(r+2)%10]&n[(r+4)%10]}t[0]^=b[r],t[1]^=k[r]}n.fill(0)}class U extends u{constructor(e,n,r,s=!1,o=24){if(super(),this.blockLen=e,this.suffix=n,this.outputLen=r,this.enableXOF=s,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,t(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var i;this.state=new Uint8Array(200),this.state32=(i=this.state,new Uint32Array(i.buffer,i.byteOffset,Math.floor(i.byteLength/4)))}keccak(){A(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){n(this);const{blockLen:e,state:r}=this,s=(t=h(t)).length;for(let n=0;n<s;){const o=Math.min(e-this.pos,s-n);for(let e=0;e<o;e++)r[this.pos++]^=t[n++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:n,blockLen:r}=this;t[n]^=e,0!=(128&e)&&n===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){n(this,!1),e(t),this.finish();const r=this.state,{blockLen:s}=this;for(let e=0,n=t.length;e<n;){this.posOut>=s&&this.keccak();const o=Math.min(s-this.posOut,n-e);t.set(r.subarray(this.posOut,this.posOut+o),e),this.posOut+=o,e+=o}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(e){return t(e),this.xofInto(new Uint8Array(e))}digestInto(t){if(function(t,n){e(t);const r=n.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:n,outputLen:r,rounds:s,enableXOF:o}=this;return t||(t=new U(e,n,r,o,s)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=n,t.outputLen=r,t.enableXOF=o,t.destroyed=this.destroyed,t}}const x=(t,e,n)=>function(t){const e=e=>t().update(h(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}((()=>new U(e,t,n))),E=x(6,144,28),O=x(6,136,32),m=x(6,104,48),B=x(6,72,64),N=x(1,144,28),v=x(1,136,32),F=x(1,104,48),X=x(1,72,64),$=(t,e,n)=>function(t){const e=(e,n)=>t(n).update(h(e)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=e=>t(e),e}(((r={})=>new U(e,t,void 0===r.dkLen?n:r.dkLen,!0))),M=$(31,168,16),j=$(31,136,32);export{U as Keccak,A as keccakP,N as keccak_224,v as keccak_256,F as keccak_384,X as keccak_512,E as sha3_224,O as sha3_256,m as sha3_384,B as sha3_512,M as shake128,j as shake256};export default null;